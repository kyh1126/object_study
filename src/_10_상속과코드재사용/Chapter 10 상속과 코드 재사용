# Chapter 10. 상속과 코드 재사용

---

핵심 : '상속'은 코드 재사용과 관련된 대부분의 경우에 우아한 해결방법이 아니며, 상속의 단점을 피하면서도 코드를 재사용할 수 있는 더 좋은 방법은 '합성'이다.

## 01. 상속과 중복 코드

---

- 신뢰할 수 있고 수정하기 쉬운 소프트 웨어를 만드는 효과적인 방법 중 하나는 중복을 제거하는 것이다.
- DRY (Don't Repeat Yourself) 원칙
    - 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 한다.
    - 한번, 단 한번(Once and Only Once) 원칙, 단일 지점 제어(Single-Point Control) 원칙이라고도 부른다.
- 중복과 변경
    - 중복 코드는 새로운 중복 코드를 부른다. 중복 코드를 제거하지 않은 상태에서 코드를 수정할 수 있는 유일한 방법은 중복 코드를 추가하는 것 뿐이다.
    - 중복 코드가 늘어날수록 애플리케이션은 변경에 취약해지고 버그가 발생할 가능성이 높아진다.
    - 중복 코드의 양이 많아질수록 버그는 증가하며 코드를 변경하는 속도는 점점 느려진다.
- 상속을 이용해서 중복 코드 제거하기
    - 상속의 기본 아이디어 - 이미 존재하는 클래스와 유사한 클래스가 필요하다면 코드를 복사하지 말고 상속을 이용해 코드를 재사용하라는 것.
    - 상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하는 것은 쉽지 않다.
    - **그러나** 상속을 이용해 코드를 재사용하기 위해서는 부모 클래스의 개발자가 세운 가정과 추론 과정을 정확히 이해해야 하고 자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 한다는 것을 의미한다 → 결합도가 높다 → 부모/자식 클래스간의 강결합으로 인해 코드 수정이 어려워진다.
- 강하게 결합된 부모 클래스(Phone)와 자식 클래스(NightlyDiscountPhone)
    - 부모 코드를 수정할 때 유사한 코드를 자식 클래스에도 추가해야하는 경우가 발생한다 → 자식 클래스가 부모 클래스에 강결합 되어있어 발생한다.
    - 중복 코드의 양이 많아질수록 버그는 증가하며 코드를 변경하는 속도는 점점 느려진다.

## 02. 취약한 기반 클래스 문제

---

- 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상 (Fragile Base Class Problem, Brittle Base Class Problem). 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리킴.

- 겉보기에는 안전한 방식으로 기반 클래스를 수정한 것처럼 보이더라도 이 새로운 행동이 파생 클래스에게 상속될 경우 파생 클래스의 잘못된 동작을 초래할 수 있다. (취약하다)

- 핵심적인 기반 클래스에 대한 단순한 변경이 전체 프로그램을 불안정한 상태로 만들어버릴 수도 있다.

- 상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다.

- 불필요한 인터페이스 상속 문제
    - [java.util.Properties](http://java.util.Properties) 와 java.util.Stack 의 예
    - 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트리게 될 수 있다 → 퍼블릭 인터페이스의 고려 없이 단순히 코드 재사용을 위해 상속을 이용할 경우 불필요한 오퍼레이션이 인터페이스에 스며들면 안된다.
- 메서드 오버라이딩의 오작용 문제
    - HashSet을 상속받은 InstrumentedHashSet의 예
    - 클래스가 상속되기를 원한다면 상속을 위해 클래스를 설계하고 문서화 해야하며, 그렇지 않은 경우에는 상속을 금지해야한다.

        → **메서드 오버라이딩으로 인한 파급 효과를 분명히 문서화해야 한다.**

        → 오버라이딩 가능한 메서드들의 자체사용(self-use), 즉 메서드들이 같은 클래스의 다른 메서드를 호출하는지에 대해 반드시 문서화해야 한다.

        → public이나 protected 메서드 및 생성자가 어떤 오버라이딩 가능한 메서드를 호출하는지, 어떤 순서로 하는지, 호출한 결과가 다음 처리에 어떤 영향을 주는지에 대해서도 반드시 문서화해야 한다.

    - 설계는 트레이드오프이다. 상속을 하며 문서를 작성하는 것은 캡슐화를 위반하는 것이지만, 서브클래스가 안전할 수 있게끔 클래스를 문서화해야한다.

        → 완벽한 캡슐화를 원한다면? 코드 재사용의 포기 or 상속 이외의 방법을 사용

- 부모 클래스와 자식 클래스의 동시 수정 문제
    - 자식 클래스가 부모 클래스의 메서드를 오버라이딩하거나 불필요한 인터페이스를 상속받지 않았음에도, 부모 클래스를 수정할 때 자식 클래스를 함께 수정해야 할 수도 있다.
    - 부모 클래스의 작성자가, 애초부터 확장될 목적으로 그 클래스를 설계하지 않았다면 자식 클래스는 부모클래스와 보조를 맞춰서 진화해야한다. (강결합이 원인이 됨)

## 03. Phone 다시 살펴보기

---

- 상속으로 인한 피해를 최소화 할 수 있는 방법은 '추상화'이다.
- 추상화에 의존하자
    - 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
    - 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.
- 차이를 메서드로 추출하라
    - 중복 코드 안에서 차이점을 별도의 메서드로 추출해야한다
    - 변하는 부분을 찾고 이를 캡슐화하라. 변하는 것으로부터 변하지 않는 것을 분리하라.
- 중복 코드를 부모 클래스로 올려라
    - 모든 클래스들이 추상화에 의존하도록 하는 것이 목표이기 때문에 부모 클래스를 추상 클래스로 구현한다.
    - '위로 올리기' 전략은 실수, 실패하더라도 추상화할 코드는 눈에 띄고 결국 상위 클래스로 올려지면서 코드의 품질이 높아진다.
- 추상화가 핵심이다
    - 부모 클래스에서 정의한 추상메서드에만 의존하게 되면, 메서드의 시그니처가 변경되지 않는 한 부모 클래스의 내부 구현이 변경되더라도 자식 클래스는 영향을 받지 않는다. → 낮은 결합도
    - 부모 클래스 역시 자신의 내부에 구현된 추상 메서드를 호출하기 때문에 추상화에 의존한다고 할 수 있다.
    - 의존성 역전 원칙도 준수하며, 확장에는 열리게 되고 수정에는 닫히게 되어 개방-폐쇄 원칙 역시 준수하게  된다.
    - 상속 계층이 코드를 진화시키는데 걸림돌이 되면 추상화를 찾아내고, 상속 계층 안의 클래스들이 추상화에 의존하돌고 리팩토링하라.
- 의도를 드러내는 이름 선택하기
    - 클래스의 이름은 구현하는 내용에 대한 사실을 명확히 전달해야한다.
    - 추상화에 의존한다는 것은 구현 내용이 아닌 인터페이스에 의존한다는 것이므로, 그 의도를 잘 드러내도록 네이밍을 해야한다.
- 뭔 짓을 해도 상속 으로 인한 클래스 사이의 결합을 피할 수 있는 방법은 없다 → 관련한 모든 코드 작성은 결국 트레이드오프일 뿐....

## 04. 차이에 의한 프로그래밍

---

- 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법 (상속)
- 목표 : 중복 코드를 제거하고 코드를 재사용하는 것.
- 상속을 이용하면 새로운 기능을 추가하기 위해 직접 구현해야 하는 코드의 양을 최소화 할 수 있다.
- 상속은 코드 재사용 측면에서는 강력하지만, 오남용할 경우 애플리케이션을 이해하고 확장하기 어렵게 만드므로 정말 필요한 경우에만 상속을 사용하라.

## * 상속을 위한 경고

---

- 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.
- 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트리게 될 수 있다
- 자식 클래스가 부모 클래스의 메서들들 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
- 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없다.