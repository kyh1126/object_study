# Chapter 2. 객체지향 프로그래밍

---

## 01. 영화 예매 시스템 애플리케이션 구현하기

---

![Chapter%202%209cf818f35fbf4f0ebd9e89110f01ebe4/ApplicationCoreClassEx1.png](Chapter%202%209cf818f35fbf4f0ebd9e89110f01ebe4/ApplicationCoreClassEx1.png)

## 02. 객체와 객체지향

---

- 객체?
    1. 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재
    2. 객체는 스스로 판단하고 행동하는 자율적인 존재

- 객체지향?
    1. 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음 → **캡슐화**
    2. 상태와 행동을 캡슐화 함은 물론 외부 접근을 통제할 수 있는 **접근제어(access control)** 메커니즘 제공

        → 접근 수정자(access modifier) 제공 - public, protected, private

    3. 인터페이스와 구현의 분리(separation of interface and implementation)가 핵심 원칙

        → 퍼블릭 인터페이스(public interface), 구현(implementation)으로 객체를 분리

- 구현 은닉 (Implementation Hiding)

인터페이스와 구현의 분리를 통해 얻는 이점 중 하나는 인터페이스 정보만 노출하기 때문에 영향도 걱정없이 내부 구현을 마음대로 변경할 수 있다는 것이다.

- 협력 (Collaboration)

시스템의 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용을 의미하며 객체간의 협력은 메서드(method)를 통해 이루어진다.

- 상속 (Inheritance)

부모 클래스가 제공하는 인터페이스를 자식 클래스가 물려받아 중복 코드를 줄이고, 코드 재사용성을 높인다. 또한 자식 클래스가 상속을 통해 부모 클래스의 인터페이스를 물려받기 때문에 부모클래스를 대신하는 **업캐스팅(Upcasting)**을 할 수 있다.

→ 구현 상속(Implementation inheritance, Subclassing) - 코드 재사용 목적

→ 인터페이스 상속(Interface Inheritance, Subtyping) - 다형적 협력을 위해 인터페이스 공유 목적

- Overriding. 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의 하는것
- Overloading. 메서드 이름은 같지만 파라미터 목록이 다른 것

- 다형성 (Polymorphism)

동일한 메시지를 수신 했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.

다형성은 컴파일 시간 의존성과 실행 시간 의존성의 차이가 있을 수 있다는 것을 기반으로 하며, 실제로 동일한 메시지를 전달하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스에 따라 달라진다.

→ 지연 바인딩(Lazy Binding)을 통해 메시지와 메서드를 실행 시점에 바인딩 한다. (컴파일 시점 X)

- 추상화 (Abstraction)

추상화 계층만 따로 보면 요구사항의 정책을 높은 수준에서 서술할 수 있다 → 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다. 디자인패턴, 프레임워크 역시 추상화를 이용한다.

추상화를 이용하면 설계가 좀 더 유연해진다 → 기존 구조를 변경하지 않고도 새로운 기능을 쉽게 추가/확장 가능하다

## 03. 설계 개선하기

---

기존문제

- 기존문제

    '스타워즈'의 할인 정책이 해결되지 않았다 → 할인 정책이 없는 경우를 예외 케이스로 취급한다. (일관성이 무너진다.)

- NoneDiscountPolicy 를 추가한다.

    → 할인 되지않는 경우를 '예외'로 두지 않고 할인금액 = 0원 의 개념으로 일관성을 유지한다.

    → 이 경우처럼 추상화를 중심으로 코드의 구조를 설계하면 유연하고 확장 가능한 설계를 만들 수 있다.

    ![Chapter%202%209cf818f35fbf4f0ebd9e89110f01ebe4/ApplicationCoreClassEx2.png](Chapter%202%209cf818f35fbf4f0ebd9e89110f01ebe4/ApplicationCoreClassEx2.png)

- 코드 재사용의 방법
- 상속(Inheritance)

    코드 재사용성 측면에서 사용한다.

    - 상속의 단점
        - 부모 클래스의 내부 구조를 잘 알고 있어야 한다 → 캡슐화를 위반한다 → 결합이 강해진다
        - 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다 → 설계를 유연하지 못하게 만든다.
- 합성(Composition)

    인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법이다.

    - 합성의 장점
        - 인터페이스에 정의된 메시지를 통해서만 코드를 재사용한다 → 구현을 효과적으로 캡슐화 할 수 있다.
        - 상속은 클래스를 통해 강하게 결합되는 데 비해 합성은 메시지를 통해 느슨하게 결합된다

이처럼 코드를 재사용하는 경우에는 상속보다 합성을 선호하는 것이 맞지만, 다형성(Polymorphism)을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해 사용한다.

- 객체지향의 핵심
1. 객체지향에서 가장 중요한 것은 애플리케이션의 기능을 구현하기 위해 협력에 참여하는 객체들 사이의 상호작용이다.
2. 객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것.

[https://www.notion.so/Chapter-2-653d026aa4404205b473ee55330b9a0c](https://www.notion.so/Chapter-2-653d026aa4404205b473ee55330b9a0c)