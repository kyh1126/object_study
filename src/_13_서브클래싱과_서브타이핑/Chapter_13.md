# Chapter 13. 서브클래싱과 서브타이핑

## 01. 타입

- 개념 관점의 타입
    - 우리가 인지하는 세상의 사물의 종류, 공통의 특징을 공유하는 대상들의 분류.
    - 어떤 대상이 타입으로 분류됨 → 타입의 인스턴스 (객체)
    - ex> 자바는 프로그래밍 언어(타입)의 인스턴스
- 프로그래밍 언어 관점의 타입
    - 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합.
    - 비트 묶음에 의미, 제약 부여하기 위해 사용.
    - 2가지 사용 목적
        - 타입에 수행될 수 있는 유효한 오퍼레이션 집합 정의.
        - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공.
- 객체지향 패러다임 관점의 타입
    - 객체의 퍼블릭 인터페이스가 객체의 타입을 결정.
    - 퍼블릭 인터페이스: 객체가 수신할 수 있는 메시지(오퍼레이션)의 집합

객체에게 중요한 것은 속성이 아니라 행동!

## 02. 타입 계층

- 타입 사이의 포함관계
    - 일반화 vs 특수화 = 슈퍼타입 vs 서브타입
- 퍼블릭 인터페이스 관점
    - 슈퍼타입: 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적, 넓은 의미로 정의
    - 서브타입: 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적, 좁은 의미로 정의

서브타입의 인스턴스 → 슈퍼타입의 인스턴스!

## 03. 서브클래싱과 서브타이핑

- 아래 두 조건을 다 만족할 경우가 상속을 사용해야 할 때!
    1. 상속 관계가 is-a 관계를 모델링하는가?

        → 자식 클래스는 부모 클래스다 라고 말할 수 있을때.

    2. 클라이언트 입장에서 부모 클래스 타입으로 자식 클래스를 사용해도 무방한가?

        → 클라이언트 입장에서 부모/자식 클래스의 차이를 몰라야 한다. (행동 호환성)

- 행동호환성

새는 날 수 있지만 펭귄은 날 수 없다. 이래도 새를 상속받으면? → 클라이언트의 기대에 따라 계층을 분리하자.

- 인터페이스 분리 원칙

인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙.

새를 상속받은 날 수 있는 새, 날 수 없는 새로 분리하자! 단, 요구사항이 있을 때만!

- 서브클래싱: 다른 클래스 코드 재사용할 목적으로 상속을 사용하는 경우. 자식, 부모 행동이 호환되지 않아 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.

    → 구현 상속, 클래스 상속

- 서브타이핑: 타입 계층을 구성하기 위해 상속을 사용하는 경우.  자식, 부모 행동이 호환되어 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.

    → 인터페이스 상속

## 04. 리스코프 치환 원칙

서브타입은 기반 타입에 대해 대체 가능해야 한다. 클라이언트가 차이점을 인식하지 못한 채 파생 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.

- Stack과 Vector도 리스코프 치환 원칙을 위반한다.
    - 협력하는 클라이언트가 Stack과 Vector에 대해 전송할 수 있는 메시지와 기대하는 행동이 서로 다르다.

→ 클라이언트와 격리한 채로 본 모델은 의미있게 검증하는 것이 불가능.

## 05. 계약에 의한 설계와 서브타이핑

클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것.

- 계약에 의한 설계 3가지 구성 요소
    - 사전조건
        - 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 것.
        - 만족되지 않을 경우 메서드가 실행되면 안됨.
        - 이를 만족시키는 것은 메서드를 실행하는 클라이언트의 의무.
    - 사후조건
        - 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 것.
        - 명시된 사후조건을 만족시키지 못할 것 같으면 클라이언트에게 예외를 던져야 함.
        - 3가지 사용 용도
            1. 인스턴스 변수의 상태가 올바른지 서술하기 위해
            2. 메서드에 전달된 파라미터 값이 올바르게 변경됐는지 서술하기 위해
            3. 반환값이 올바른지 서술하기 위해
    - 클래스 불변식
        - 메서드 실행 전, 후에 인스턴스가 만족시켜야 하는 것.
        - 항상 참이라고 보장되는 서버의 조건.
        - 메서드가 실행되는 도중 불변식을 만족시키지 못할 수도 있지만 메서드를 실행하기 전이나 종료된 후에 불변식은 항상 참이어야 함.

→ 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간 계약을 준수해야 한다.

- 예시를 보았다.. 그러나 설득이 안되는걸.. 계약에 의한 설계의 장점이 뭐지?

## 부록 A _  계약에 의한 설계

- 부수효과를 명시적으로
    - 계약에 의한 설계를 사용하면 제약 조건을 명시적으로 표현하고 자동으로 문서화 할 수 있을 뿐 아니라 실행을 통해 검증할 수 있다.
    - 예시
        - PopupBannerService

            ```java
            @Transactional
            public void createPopupBanner(PopupBannerRequest request) {
            	ValidatorUtils.validateAndThrow(SaveState.NEW, popupBannerRequestValidator, request);

            	PopupBanner banner = new PopupBanner();
            	savePopupBanner(request, banner);
            }
            ```

        - Scala

            ```scala
            case class ZipCode(zip: Int, extension: Option[Int] = None) {
              require(valid(zip, extension), s"Invalid Zip+4 specified: $toString")

              protected def valid(z: Int, e: Option[Int]): Boolean = {
                if (0 < z && z <= 99999) e match {
                  case None    => validUSPS(z, 0)
                  case Some(e) => 0 < e && e <= 9999 && validUSPS(z, e)
                }
                else false
              }

              protected def validUSPS(i: Int, e: Int): Boolean = true

              override def toString = if (extension != None) s"$zip-${extension.get}" else zip.toString
            }
            ```

- 리스코프 치환 원칙의 규칙
    - 계약 규칙
        - 협력에 참여하는 객체에 대한 기대를 표현.
        - 슈퍼타입과 서브타입 사이의 사전조건, 사후조건, 불변식에 대해 서술할 수 있는 제약에 관한 규칙.

        ```
        - 서브타입에 더 강력한 사전조건을 정의할 수 없다.
        - 서브타입에 더 완화된 사후조건을 정의할 수 없다.
        - 슈퍼타입의 불변식은 서브타입에서도 반드시 유지돼야 한다.
        ```

    - 가변성 규칙
        - 교체 가능한 타입과 관련됨.
        - 파라미터와 리턴 타입의 변형과 관련된 규칙.
        - 시간이 나면 코틀린과 스칼라의 공변성, 반공변성 예시 설명해보자.

        ```
        - 서브타입의 메서드 파라미터는 반공변성을 가져야 한다.
        - 서브타입의 리턴 타입은 공변성을 가져야 한다.
        - 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안 된다.
        ```
https://www.notion.so/Chapter-13-0161420bc09043b486c5a1623d7e7341
